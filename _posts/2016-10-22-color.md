---
layout: post
title:  "Clearly Color Categories"
date:   2016-10-22 16:21:00 -0400
excerpt_separator: <!--more-->
categories: jekyll update
---

As a grad student, I work a lot with satellite data. This satellite data sometimes has categorical information like whether 
the pixel is from a broken detector or it's nightime in that pixel or ocean. Often this data also measures something, 
and both these things should go on a plot(please forgive the colors):
![img](/assets/figs/stas.png)
<!--more-->
```Python
import matplotlib.colors as mcolors
import matplotlib.cm as mcm
import matplotlib.patches as mpatches

# Create a custom color scheme for the missing value codes
colors = ["#FFCCCC", "#FFCC99", "#CCCCCC", 
          "#CC9933", "#99FFFF", "#66FFFF", 
          "#999999", "#CC9999", "#666666"]
mcmap = mcolors.ListedColormap(colors)
mnorm = mcolors.BoundaryNorm([200, 201, 211, 225, 237,239, 250, 254,255, 260], mcmap.N)
#make proper legend for the missing data
labels = ['missing data', 'no decision', 'night', 
         'land', 'inland water', 'ocean', 
         'cloud', 'detector saturated', 'fill']
         
def plot_fsc(fig, ax, snow, codes):
    cd = ax.imshow(codes, cmap=mcmap, norm=mnorm, interpolation='nearest')
# everything else omitted

patches = [mpatches.Patch(color=c, label=l) for c, l in zip(colors, labels)]
ax3.legend(patches, labels, ncol=1, loc=6)
```
Even edited such that the non-categorical stuff is omitted, that's a lot of boilerplate. But, even worse, it's confusing 
as all out because 260 isn't even in the data but necessary to exploit
[`BoundaryNorm`](http://matplotlib.org/api/colors_api.html?highlight=boundarynorm#matplotlib.colors.BoundaryNorm), which 
assigns colors based on `lower bound <= value < upper bound`
